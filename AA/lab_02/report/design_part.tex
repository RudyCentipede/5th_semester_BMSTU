\chapter{Конструкторская часть}

\section{Функциональные требования}

Разработать программное обеспечение с двумя режимами работы: режимом определения количества единиц в последовательности, состоящей из нулей и единиц, заканчивающейся числом 2, и режимом массированного замера времени выполнения реализаций рекурсивного и нерекурсивного алгоритмов.

\textbf{Входные данные:}
\begin{itemize}
	\item пункт меню (целое число от 0 до 3),
	\item элементы последовательности -- целые числа от 0 до 2.
\end{itemize}

\textbf{Выходные данные:}

Целое число -- количество единиц в последовательности.

\section{Схемы алгоритмов}

На рисунках~\ref{alg:iter} --~\ref{alg:rec} представлены схемы алгоритмов.


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.9]{images/iter.png}
	\caption{Схема нерекурсивного алгоритма}
	\label{alg:iter}
\end{figure}
\clearpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.65]{images/recursive.png}
	\caption{Схема рекурсивного алгоритма}
	\label{alg:rec}
\end{figure}
\clearpage



\section{Модель вычислений}

Чтобы вычислить трудоёмкость алгоритмов, введена следующая модель вычислений:

\begin{enumerate}
	\item базовые операции:
	\begin{itemize}
		\item трудоёмкость операций из списка~(\ref{costOne}) равна 1:
		\begin{equation}
			\label{costOne}
			\begin{gathered}
			=, +, \mathrel{+}=, -, \mathrel{-}=, ++, --, ==, \mathrel{!}=, <, <=, >=, >, [], \&\&,\\
			 \&, >>, <<, ||, |
			\end{gathered}
		\end{equation}
		\item трудоёмкость операций из списка~(\ref{costTwo}) равна 2:
		\begin{equation}
			\label{costTwo}
			\begin{gathered}
				*, \mathrel{*}=, /, \mathrel{/}=, \%, \mathrel{\%}=
			\end{gathered}
		\end{equation}
	\end{itemize}
	\item трудоёмкость условного перехода равна 0,
	\item трудоёмкость условного оператора по формуле~(\ref{if}):
	\begin{equation}
		\label{if}
		f_{if} = f_{\text{условия}} + 
		\begin{cases}
			min(f_A, f_B), & \text{-- лучший случай}\\
			max(f_A, f_B) & \text{-- худший случай}
		\end{cases}
	\end{equation}
	\item трудоёмкость цикла по формуле~(\ref{for}):
	\begin{equation}
		\label{for}
		\begin{gathered}
			f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + M\cdot(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
		\end{gathered}
	\end{equation}
	где $M$ -- число итераций.
	\item трудоёмкость одного рекурсивного вызова-возврата по формуле~(\ref{rec}):
	\begin{equation}
		\label{rec}
		\begin{gathered}
			f_{R}(1) = 2\cdot (p + k + r + l + 1),
		\end{gathered}
	\end{equation}
	где $p$ --  количество передаваемых фактических параметров,\\
	$k$ -- количество возвращаемых по адресной ссылке значений,\\
	$r$ -- количество сохраняемых в стек регистров,\\
	$l$ --  количество локальных ячеек процедуры, сохранение которых необходимо для обеспечения реентерабельности,
	
	\item трудоёмкость рекурсивного алгоритма по формуле~(\ref{recal}):
	\begin{equation}
		\label{recal}
		\begin{gathered}
			f_{A}(D) = R(D)\cdot f_{R}(1) + R_{L}(D)\cdot f_{CL}(v) + R_{V}(D)\cdot f_{CV}(v),
		\end{gathered}
	\end{equation}
	где $R(D)$ -- общее количество вершин дерева рекурсивных вызовов,\\
	$R_{V}(D)$ -- количество внутренних вершин дерева рекурсивных вызовов,\\
	$R_{L}(D)$ -- количество листовых вершин дерева рекурсивных вызовов,\\
	$f_{R}(1)$ -- трудоёмкость одного рекурсивного вызова-возврата,\\
	$f_{CL}(v)$ -- трудоёмкость вычислений в листовых вершинах дерева рекурсивных вызовов,\\
	$f_{CV}(v)$ -- трудоёмкость вычислений во внутренних вершинах дерева рекурсивных вызовов.
	
\end{enumerate}

\section{Трудоёмкость алгоритмов}

\subsection{Нерекурсивный алгоритм}

Трудоёмкость нерекурсивного алгоритма рассчитана по формулам~(\ref{std:first} --~\ref{std:last}):
\begin{equation}
	\label{std:first}
	f_{cycle} = 2 + N \cdot (2 + f_{body}),
\end{equation}
\begin{equation}
	f_{body} = 2 + 
	\begin{cases}
		0, & \text{-- лучший случай}\\
		2 & \text{-- худший случай}
	\end{cases}
\end{equation}
Итого, для худшего случая по формуле~(\ref{std:last}):
\begin{equation}
	\label{std:last}
	f_{algo} = 2 + N \cdot (2 + 4) = 6N + 2.
\end{equation}

Асимптотическая оценка временной сложности алгоритма: $O(N)$.

\subsection{Рекурсивный алгоритм}

Трудоёмкость рекурсивного алгоритма рассчитана по формулам~(\ref{rec:init} --~\ref{rec:al}):

\begin{itemize}
	\item количество передаваемых параметров $p$ равно 2, количество сохраняемых регистров $r$ равно 19~\cite{article_64}, тогда трудоёмкость одного рекурсивного вызова-возврата по формуле~(\ref{rec:init}):
	\begin{equation}
		\label{rec:init}
			f_{R}(1) = 2\cdot (2 + 0 + 19 + 0 + 1) = 44,
	\end{equation}
	\item трудоёмкость вычислений в листовых вершинах дерева рекурсивных вызовов по формуле~(\ref{rec:list}):
	\begin{equation}
		\label{rec:list}
		f_{CL}(v) = 2,
	\end{equation}
	
	\item трудоёмкость вычислений во внутренних вершинах дерева рекурсивных вызовов по формуле~(\ref{rec:in}):
	\begin{equation}
		\label{rec:in}
		f_{CV}(v) = 2 + 2 + 1 = 5,
	\end{equation}

	\item общее количество вершин дерева рекурсивных вызовов по формуле~(\ref{cnt:total}):
	\begin{equation}
		\label{cnt:total}
		R(D) = N,
	\end{equation}
	
	\item количество листовых вершин дерева рекурсивных вызовов по формуле~(\ref{cnt:list}):
	\begin{equation}
		\label{cnt:list}
		R_{L}(D) = 1,
	\end{equation}
	
	\item количество внутренних вершин дерева рекурсивных вызовов по формуле~(\ref{cnt:in}):
	\begin{equation}
		\label{cnt:in}
		R_{V}(D) = N - 1,
	\end{equation}
	
	\item трудоёмкость алгоритма по формуле~(\ref{rec:al}):
	\begin{equation}
		\label{rec:al}
		\begin{gathered}
			f_{A}(D) = N\cdot 44 + 1\cdot 2 + (N - 1)\cdot 5 = 49N - 3.
		\end{gathered}
	\end{equation}

Асимптотическая оценка временной сложности алгоритма: $O(N)$.

\end{itemize}


\clearpage

\section{Вывод}

В данном разделе были описаны функциональные требования к программе, построены схемы алгоритмов: нерекурсивного и рекурсивного. 

Была введена модель вычислений, в соответствии с которой были рассчитаны трудоёмкости алгоритмов. Проведённая оценка трудоёмкости алгоритмов показала, что трудоёмкость выполнения рекурсивного алгоритма в 8.2 раза больше, чем у нерекурсивного.

\clearpage
