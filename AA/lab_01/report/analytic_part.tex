\chapter{Аналитическая часть}

\section{Матрица}

Матрицей размера [$m\times n$] называют прямоугольную таблицу чисел, функций или алгебраических выражений, содержащую m строк и n столбцов.~\cite{book_belousov}

Пусть A –- матрица, состоящая из m строк и n столбцов. Тогда она имеет вид:

\begin{equation}
	A_{m\times n} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{m2} & \ldots & a_{mn}
	\end{pmatrix},
\end{equation}

где $a_{ij}$ – элемент матрицы A, который находится на строке i и в столбце j.

\bigskip
Можно выделить следующие операции над матрицами:
\begin{enumerate}
	\item сложение матриц одинаковых размеров,
	\item вычитание матриц одинаковых размеров,
	\item умножение матриц, если количество столбцов первой матрицы равно количеству строк второй матрицы.~\cite{book_belousov}
	
\end{enumerate}

\section{Стандартный алгоритм}

Пусть даны прямоугольные матрицы $A_{m\times n}$ и $B_{n\times k}$:

\begin{equation}
	A_{m\times n} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1n}\\
		a_{21} & a_{22} & \ldots & a_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{m1} & a_{l2} & \ldots & a_{mn}
	\end{pmatrix},
	\quad
	B_{n\times k} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1k}\\
		b_{21} & b_{22} & \ldots & b_{2k}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{n1} & b_{m2} & \ldots & b_{nk}
	\end{pmatrix},
\end{equation}

Тогда матрица $C_{m \times k}$:

\begin{equation}
	C_{m\times k} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1k}\\
		c_{21} & c_{22} & \ldots & c_{2k}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{m1} & c_{m2} & \ldots & c_{mk}
	\end{pmatrix},
\end{equation}


где \begin{equation}
	c_{ij} =
	\sum_{r=1}^{n} a_{ir}b_{rj} \quad (i=\overline{1,m}; j=\overline{1,k})
\end{equation}

называется произведением матриц A и B.


\section{Алгоритм Винограда}

Алгоритм Винограда -- алгоритм умножения квадратных матриц, предложенный в 1987 году Д. Копперсмитом и Ш. Виноградом.  В исходной версии асимптотическая сложность алгоритма составляла $O(n^{2,3755})$, где n — размер стороны матрицы. В 2020 году Джош Алман и Вирджиния Вильямс улучшили метод, достигнув оценки $O(n^{2,3728596})$.~\cite{book_golovashkin}

\bigskip

Два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$.
Их скалярное произведение равно: $V \cdot W = v_1w_1 + v_2w_2 + v_3w_3 + v_4w_4$. Преобразовав выражение, получим:
\begin{equation}
	\label{eq:vw}
	V \cdot W = (v_1 + w_2)(v_2 + w_1) + (v_3 + w_4)(v_4 + w_3) - v_1v_2 - v_3v_4 - w_1w_2 - w_3w_4.
\end{equation}

При нечётной длине перемножаемых векторов к каждой ячейке результирующей матрицы добавится одно слагаемое.

Свяжем стандартный метод умножения матриц со скалярным произведением строки матрицы A на столбец B. Скалярное произведение (\ref{eq:vw}) можно произвести иначе:

\begin{equation}
	\label{eq:c}
	C_{ij} = \sum_{k=1}^{n/2}(a_{i,2k-1} + b_{2k,j})(a_{i,2k} + b_{2k-1,j}) - \sum_{k=1}^{n/2} a_{i,2k-1}a_{i,2k} - \sum_{k=1}^{n/2} b_{2k-1,j}b_{2k,j}
\end{equation}

Виноград предложил находить второе и третье слагаемые в формуле (\ref{eq:vw}) на предварительном этапе вычислений, заранее для каждой строки матрицы A и 
столбца B соответственно. Так, вычислив единожды для строки i матрицы A значение выражения 
\begin{equation}
\sum_{k=1}^{n/2} (a_{i,2k-1}a_{i,2k})
\end{equation}
его можно далее использовать m раз при нахождении элементов строчки i матрицы C. Ведь данное выражение участвует в определении $c_{ij}$ по формуле (\ref{eq:c}) для 
выбранного i и $1\leq j\leq m$. 

Аналогично, вычислив единожды для столбца j матрицы B значение выражения
\begin{equation}
 \sum_{k=1}^{n/2} (b_{2k-1,j}b_{2k,j})
\end{equation}
его можно далее использовать n раз при нахождении элементов столбца j матрицы C. Ведь данное выражение участвует в определении $c_{ij}$ по формуле (\ref{eq:c}) для выбранного j и $1\leq i\leq n$.~\cite{book_golovashkin}

Это означает, что над предварительно обработанными элементами по формуле (\ref{eq:vw}) придется выполнять лишь первые два умножения, последующие пять сложений и два дополнительных сложения. Операция сложения выполняется быстрее, поэтому на реализация алгоритма должна работать быстрее стандартного алгоритма перемножения матриц.


\section{Оптимизированный алгоритм Винограда}

Алгоритм Винограда оптимизирован следующим образом:

\medskip

\begin{enumerate}
	\item использовано предварительное вычисление значений (N-1, N/2 и др.),
	\item использовано накопление в буфер значения при заполнении массивов и матрицы.
\end{enumerate}

\section{Вывод}

В аналитической части были рассмотрены алгоритмы умножения матриц: стандартный алгоритм и алгоритм Винограда. Также были рассмотрены возможные оптимизации алгоритма Винограда. 


\clearpage
